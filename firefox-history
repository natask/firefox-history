#! /usr/bin/env python3
import sqlite3
import subprocess
import shlex
import argparse
import textwrap
from datetime import datetime

################### parse arg #######################
#doesn't do bound checking on argv
class RawTextArgumentDefaultsHelpFormatter(
        argparse.ArgumentDefaultsHelpFormatter,
        argparse.RawTextHelpFormatter
    ):
        pass

program_description = '''
Firefox History v0.2

Copyright (C) 2021  Natnael Kahssay

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
'''

example_text = '''example:
 firefox-history https://google.com
 '''
parser = argparse.ArgumentParser(description=program_description, epilog=example_text, formatter_class=RawTextArgumentDefaultsHelpFormatter)
parser.add_argument('url', type=str, nargs="?", default="https://gist.github.com/olejorgenb/9418bef65c65cd1f489557cfc08dde96", help=
                    textwrap.dedent('''\
Url that is to be searched in database.
        '''),metavar='Url')
parser.add_argument('--database', type=str, default="/home/savnkk/.mozilla/firefox/ynulz4el.dev-edition-default/places.sqlite", help=
                    textwrap.dedent('''\
Location of database.
        '''),metavar='Database')
parser.add_argument('--postfix', type=str, default="bak", help=
                    textwrap.dedent('''\
Postfix difference between main database and copy database to which sql will connect to.
        '''),metavar='Postfix')
parser.add_argument('--depth', type=int, default=10, help='''\
depth of backtrace and chronology for `url.''')
parser.add_argument('--stable', action="store_true", help='''\
Database is stable. It doesn't change therefore direct connection will be made to it.''')
parser.add_argument('--elisp', action="store_true", help='''\
Output in elisp form.''')
parser.add_argument('--visit', action="store_true", help='''\
Output visited dates for `url.''')
parser.add_argument('--chrono', action="store_true", help='''\
Output chronology for `url.''')
parser.add_argument('--backtrace', action="store_true", help='''\
Output backtrace for `url.''')
parser.add_argument('--query', action="store_true", help='''\
Output query result for `query by intrepreting `url as a `query.''')
################### parse arg #######################

def dateToString(date):
 return(datetime.utcfromtimestamp(date/1000000).strftime('%Y-%m-%d %H:%M:%S'));

def getQueryResults(cur, string):
 cur.execute(string);
 ret =  cur.fetchall();
 # if len(ret) > 0 and len(ret[0]) == 1:
 #  ret = list(map(lambda x : x[0], ret))
 return ret;

'''
Get visit date and url for urls that are like URL.
'''
def getVisitInfo(cur, url):
 return getQueryResults(cur, f"select visit_date, url from mine where url like {url}");

'''
Get chronological info for VISIT_INFO.
'''
def getChrono(cur, visit_info):
 chrono = {};
 for date,url in visit_info:
  chrono[date] = {"url": url, "left" : [ ], "right" : []}
  chrono_date = chrono[date]
  chrono_date["right"] = getQueryResults(cur, f"select url, visit_date from mine where visit_date > {date} limit {DEPTH}")
  chrono_date["left"] = getQueryResults(cur, f"select url, visit_date from mine where visit_date < {date} order by visit_date desc limit {DEPTH}")
  chrono_date["left"] = chrono_date["left"][::-1]
 return chrono;

'''
Get backtrace info for VISIT_INFO.
'''
def getBacktrace(cur, visit_info):
 backtrace = {}
 for date,url in visit_info:
  res = cur.execute(f"select hid from mine where visit_date = {date} limit 10")
  if res := cur.fetchone():
   hid = res[0]

   backtrace[date] = {"url": url, "backtrace": []}
   backtrace_date = backtrace[date]["backtrace"]
   depth = 0;
   while hid != 0 or depth < DEPTH:
    depth = depth + 1;
    cur.execute(f"select from_visit from mine where hid={hid}")
    if res := cur.fetchone():
     hid = res[0]
    else:
     hid = 0;

    if (hid != 0):
     backtrace_date += getQueryResults(cur, f"select visit_date,url from mine where hid={hid}")

 return backtrace;

def print_chrono_normal(chrono):
 print()
 print("Chronological track")
 print("##############################")

 for date in chrono.keys():
  for url in chrono[date]["left"]:
   print((dateToString(url[1]), url[0]))

  print()
  print((dateToString(date), chrono[date]["url"]))
  print()
  for url in chrono[date]["right"]:
   print((dateToString(url[1]), url[0]))

  print()
  print()
  print()
  print("##############################")

def print_backtrace_normal(backtrace):
 print()
 print()
 print("Back track")
 print("##############################")
 for date in backtrace.keys():
  print((dateToString(date), backtrace[date]["url"]))
  print()

  for entry in backtrace[date]["backtrace"]:
   print((dateToString(entry[0]), entry[1]))

  print()
  print()
  print()

 print("##############################")

def is_iterable(item):
 return hasattr(item, '__getitem__');

def print_iter_elisp_helper(item):
 if not is_iterable(item):
  print(item, end=" ")
 elif type(item) == type(""):
  print("\"" + item + "\"", end=" ")
 elif type(item) == type({}):
  print("(", end="");
  for val in item:
   print("(", end="");
   print_iter_elisp(val);
   print_iter_elisp(item[val]);
   print(")", end=" ");

  print(")", end="")
 else: #type(item) == type([])
  print("(", end="");
  for val in item:
   print_iter_elisp(val);

  print(")", end= "")


def print_iter_elisp(item):
 print_iter_elisp_helper(item);
 print();

def main():
 global DEPTH
 args       = parser.parse_args()
 query      = args.url
 url        = "'%" + args.url + "%'"
 database   = args.database
 postfix    = args.postfix
 DEPTH      = args.depth;
 stable     = args.stable
 elisp      = args.elisp
 backtracep = args.backtrace
 queryp     = args.query
 visitp     = args.visit
 chronop    = args.chrono

 if not stable:
  # NOTE: need to check there is no other process making calls to the copy database.
  subprocess.call(shlex.split(f"cp {database} {database + '.' + postfix}"))
  database = database + '.' + postfix
  con = sqlite3.connect(database)
  cur = con.cursor()
 try:
  cur.execute(f"create view mine as select a.id, b.id hid, a.url, b.from_visit, b.visit_date from moz_places a inner join moz_historyvisits b on b.place_id = a.id order by b.visit_date")
 except:
  pass

 visit_info = getVisitInfo(cur,url);
 chrono = chronop and getChrono(cur, visit_info);
 backtrace = backtracep and getBacktrace(cur,visit_info);
 queryResults = queryp and getQueryResults(cur,query);

 if not elisp:
  queryp and print(queryResults);
  visitp and  print(visit_info);
  chronop and print_chrono_normal(chrono);
  backtracep and print_backtrace_normal(backtrace);
 else:
  queryp and print_iter_elisp(queryResults);
  visitp and print_iter_elisp(visit_info);
  chronop and print_iter_elisp(chrono);
  backtracep and print_iter_elisp(backtrace);

 cur.close()


if __name__ == "__main__":
 main();
